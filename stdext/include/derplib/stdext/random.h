#pragma once

#include <algorithm>
#include <limits>
#include <random>
#include <vector>

#include "version.h"

namespace derplib {
inline namespace stdext {

/**
 * \brief Wrapper class for simplifying pseudo-random number generation.
 *
 * \tparam RandEngine Random number engine to use as entropy source.
 */
template<typename RandEngine = std::mt19937_64>
class random final {
 public:
  /**
   * \brief Constructs an instance of a random number generator.
   *
   * \param engine the instance of engine to use for random number generation
   */
  explicit random(RandEngine&& engine = RandEngine(std::random_device{}()));

  /**
   * \brief Generates a number based on the given distribution.
   *
   * \tparam DistributionT type of distribution
   * \param distribution instance of distribution for specifying distribution properties
   * \return A generated number.
   */
  template<typename DistributionT>
  typename DistributionT::result_type with_distribution(DistributionT distribution);
  /**
   * \brief Generates a series of numbers based on the given distribution.
   *
   * \tparam DistributionT type of distribution
   * \param n number of values to generate
   * \param distribution instance of distribution for specifying distribution properties
   * \return A container of generated numbers.
   */
  template<typename DistributionT>
  std::vector<typename DistributionT::result_type> with_distribution(std::size_t n, DistributionT distribution);

   /**
    * \return The underlying instance of the random number engine.
    */
  RandEngine& get() & noexcept;

  /**
   * \brief Generates a number based on the uniform integer distribution.
   *
   * \tparam IntType type of integer number
   * \param a inclusive lower bound
   * \param b inclusive upper bound
   * \return A number generated by the generator within the bounds of `[a,b]`.
   */
  template<typename IntType = int>
  IntType uniform_int(IntType a = 0, IntType b = std::numeric_limits<IntType>::max());
  /**
   * \brief Generates a series of numbers based on the uniform integer distribution.
   *
   * \tparam IntType type of integer number
   * \param n number of values to generate
   * \param a inclusive lower bound
   * \param b inclusive upper bound
   * \return A container of numbers generated by the generator within the bounds of `[a,b]`.
   */
  template<typename IntType = int>
  std::vector<IntType> uniform_int(std::size_t n, IntType a = 0, IntType b = std::numeric_limits<IntType>::max());

  /**
   * \brief Generates a number based on the uniform real distribution.
   *
   * \tparam RealType type of real number
   * \param a inclusive lower bound
   * \param b inclusive upper bound
   * \return A number generated by the generator within the bounds of `[a,b]`.
   */
  template<typename RealType = double>
  RealType uniform_real(RealType a = 0.0, RealType b = 1.0);
  /**
   * \brief Generates a series of numbers based on uniform real distribution.
   *
   * \tparam RealType type of real number
   * \param n number of values to generate
   * \param a inclusive lower bound
   * \param b inclusive upper bound
   * \return A container of numbers generated by the generator within the bounds of `[a,b]`.
   */
  template<typename RealType = double>
  std::vector<RealType> uniform_real(std::size_t n, RealType a = 0.0, RealType b = 1.0);

 private:
  RandEngine _engine_;
};

#if defined(DERPLIB_HAS_CPP17_SUPPORT)
template<typename RandEngine>
random(RandEngine) -> random<RandEngine>;
#endif  // defined(DERPLIB_HAS_CPP17_SUPPORT)

template<typename RandEngine>
random<RandEngine>::random(RandEngine&& engine) : _engine_{std::move(engine)} {}

template<typename RandEngine>
RandEngine& random<RandEngine>::get() & noexcept {
  return _engine_;
}

template<typename RandEngine>
template<typename DistributionT>
typename DistributionT::result_type random<RandEngine>::with_distribution(DistributionT distribution) {
  return distribution(_engine_);
}

template<typename RandEngine>
template<typename DistributionT>
std::vector<typename DistributionT::result_type> random<RandEngine>::with_distribution(std::size_t n,
                                                                                       DistributionT distribution) {
  std::vector<typename DistributionT::result_type> nums(n);
  for (typename DistributionT::result_type& r : nums) {
    r = distribution(_engine_);
  }
  return nums;
}

template<typename RandEngine>
template<typename IntType>
IntType random<RandEngine>::uniform_int(IntType a, IntType b) {
  return with_distribution(std::uniform_int_distribution<IntType>{a, b});
}

template<typename RandEngine>
template<typename IntType>
std::vector<IntType> random<RandEngine>::uniform_int(std::size_t n, IntType a, IntType b) {
  return with_distribution(n, std::uniform_int_distribution<IntType>{a, b});
}

template<typename RandEngine>
template<typename RealType>
RealType random<RandEngine>::uniform_real(RealType a, RealType b) {
  return with_distribution(std::uniform_real_distribution<RealType>{a, b});
}

template<typename RandEngine>
template<typename RealType>
std::vector<RealType> random<RandEngine>::uniform_real(std::size_t n, RealType a, RealType b) {
  return with_distribution(n, std::uniform_real_distribution<RealType>{a, b});
}

}  // namespace stdext
}  // namespace derplib
